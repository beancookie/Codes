#include <iostream>
using namespace std;

// 1:角谷猜想
// 查看 提交 统计 提问
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 所谓角谷猜想，是指对于任意一个正整数，如果是奇数，则乘3加1，如果是偶数，则除以2，
// 得到的结果再按照上述规则重复处理，最终总能够得到1。如，假定初始整数为5，计算过程分别为16、8、4、2、1。 
// 程序要求输入一个整数，将经过处理得到1的过程输出来。

// 输入
// 一个正整数N(N <= 2,000,000)
// 输出
// 从输入整数到1的步骤，每一步为一行，每一部中描述计算过程。最后一行输出"End"。如果输入为1，直接输出"End"。
// 样例输入
// 5
// 样例输出
// 5*3+1=16
// 16/2=8
// 8/2=4
// 4/2=2
// 2/2=1
// End
// 来源
// 6179

// int main() {
//     long a;
//     cin >> a;
//     // a!=1
//     while (a != 1) {    
//         // 奇数
//         if (a % 2) {
//             cout << a << "*3+1=";
//             a = a * 3 + 1;  
//             cout << a << endl;
//         } else {
//             cout << a << "/2=";
//             a /= 2;
//             cout << a << endl;
//         }
//     }
//     cout << "End";
// }

// 2:正常血压
// 查看 提交 统计 提问
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 监护室每小时测量一次病人的血压，若收缩压在90 - 140之间并且舒张压在60 - 90之间
//（包含端点值）则称之为正常，现给出某病人若干次测量的血压值，计算病人保持正常血压的最长小时数。

// 输入
// 第一行为一个正整数n，n < 100
// 其后有n行，每行2个正整数，分别为一次测量的收缩压和舒张压，中间以一个空格分隔。
// 输出
// 输出仅一行，血压连续正常的最长小时数。
// 样例输入
// 4
// 100 80
// 90 50
// 120 60
// 140 90
// 样例输出
// 2
// 来源
// 习题(5-6) 医学部 2010 期末试题 周恺

// int main() {
//     int n, sum, max;
//     max = sum = 0;
//     cin >> n;
//     for (int i = 0; i < n; ++i) {
//         int a, b;
//         cin >> a >> b;
//         if (a >=90 && a <= 140 && b >=60 && b <= 90) {
//             if (++sum > max) {
//                 max = sum;
//             }
//         } else {
//             sum = 0;
//         }
//     }
//     cout << max;
// }

// 3:数字反转
// 查看 提交 统计 提问
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 给定一个整数，请将该数各个位上数字反转得到一个新数。
// 新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例2）。

// 输入
// 输入共 1 行，一个整数N。

// -1,000,000,000 ≤ N≤ 1,000,000,000。
// 输出
// 输出共 1 行，一个整数，表示反转后的新数。
// 样例输入
// 样例 #1：
// 123

// 样例 #2：
// -380
// 样例输出
// 样例 #1：
// 321

// 样例 #2：
// -83
// 来源
// NOIP2011复赛 普及组 第一题

// int main() {
//     int a, t, check = 1;
//     cin >> a;
//     if (a < 0)  cout << "-";
//     a = abs(a);
//     while (a > 0) {
//         int tmp = a % 10;
//         a /= 10;
//         if (!tmp && check) {
//             continue;
//         }
//         check = 0;
//         if (tmp) cout << tmp;
//         else cout << "0";
//     }
// }

// 4:求特殊自然数
// 查看 提交 统计 提问
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 一个十进制自然数,它的七进制与九进制表示都是三位数，且七进制与九进制的三位数码表示顺序正好相反。
// 编程求此自然数,并输出显示。

// 输入
// 无。
// 输出
// 三行：
// 第一行是此自然数的十进制表示；
// 第一行是此自然数的七进制表示；
// 第一行是此自然数的九进制表示。
// 样例输入
// （无）
// 样例输出
// （不提供）

// int main() {
//     for (int i = 49; i <= 342; ++i) {
//         int n = i;
//         int total = 0;
//         int p70 = n % 7;
//         n /= 7;
//         int p71 = n % 7;
//         n /= 7;
//         int p72 = n % 7;    
//         if (p70 * 81 + p71 * 9 + p72 == i) {
//             cout << i << endl;
//             cout << p72 << p71 << p70 << endl;
//             cout << p70 << p71 << p72 << endl;
//         }
//     }
// }

// 5:雇佣兵
// 查看 提交 统计 提问
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 雇佣兵的体力最大值为M，初始体力值为0、战斗力为N、拥有X个能量元素。

// 当雇佣兵的体力值恰好为M时，才可以参加一个为期M天的战斗期，战斗期结束体力值将为0。
// 在同一个战斗期内，雇佣兵每连续战斗n天，战斗力就会上升1点，n为当前战斗期开始时的战斗力。

// 一个战斗期结束后，雇佣兵需要用若干个能量元素使其体力恢复到最大值M，从而参加下一个战斗期。
// 每个能量元素恢复的体力值不超过当前的战斗力。每个能量元素只能使用一次。

// 请问：雇佣兵的战斗力最大可以到达多少。

// 输入
// 一行包括三个整数M、N、X，相邻两个整数之间用单个空格隔开。M、N、X均为不超过10000的正整数。
// 输出
// 输出一个整数，为雇佣兵的最大战斗力。
// 样例输入
// 5 2 10
// 样例输出
// 6

// int main() {
//     int m, n, x;
// }

// 6:数字统计
// 查看 提交 统计 提问
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 请统计某个给定范围[L, R]的所有整数中，数字2出现的次数。

// 比如给定范围[2, 22]，数字2在数2中出现了1次，在数12中出现1次，在数20中出现1次，
// 在数21中出现1次，在数22中出现2次，所以数字2在该范围内一共出现了6次。

// 输入
// 输入共 1 行，为两个正整数 L 和 R，之间用一个空格隔开。
// 输出
// 输出共 1 行，表示数字 2 出现的次数。
// 样例输入
// 样例 #1：
// 2 22

// 样例 #2：
// 2 100
// 样例输出
// 样例 #1：
// 6

// 样例 #2：
// 20
// 来源
// NOIP2010复赛 普及组 第一题

// int main() {
//     int a, b, sum = 0;
//     cin >> a >> b;
//     for (int i = a; i <= b; ++i) {
//         int tmp = i;
//         while (tmp > 0) {
//             if (2 == tmp % 10)
//                 ++sum;
//             tmp /= 10;
//         }
//     }
//     cout << sum;
// }

// 阶乘和

int main() {
    int n;
    cin >> n;
    int sum = 0;
    int tmp = 1;
    for (int i = 1; i <= n; ++i) {
        tmp *= i;
        sum += tmp;
    }
    cout << sum;
}